<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>trax.data.inputs &#8212; Homunculi Hypergraphia 0.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/monkey-style.css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html">
          Homunculi Hypergraphia</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../trax/index.html">Trax</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../trax/index.html#indices-and-tables">Indices and tables</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
              
                
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for trax.data.inputs</h1><div class="highlight"><pre>
<span></span><span class="c1"># coding=utf-8</span>
<span class="c1"># Copyright 2021 The Trax Authors.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="c1"># Lint as: python3</span>
<span class="sd">&quot;&quot;&quot;Trax input pipeline.</span>

<span class="sd">In Trax we encourage to use combinators to construct input pipelines in a way</span>
<span class="sd">that resembles layer combinators. Here is an example of an input pipeline for</span>
<span class="sd">training sentiment analysis tasks on the IMDB dataset::</span>

<span class="sd">  inputs = data.Serial(</span>
<span class="sd">    data.TFDS(&#39;imdb_reviews&#39;, keys=(&#39;text&#39;, &#39;label&#39;), train=True),</span>
<span class="sd">    data.Tokenize(vocab_file=&#39;en_8k.subword&#39;, keys=[0]),</span>
<span class="sd">    data.Shuffle(),</span>
<span class="sd">    data.FilterByLength(max_length=2048, length_keys=[0]),</span>
<span class="sd">    data.BucketByLength(boundaries=[  32, 128, 512, 2048],</span>
<span class="sd">                        batch_sizes=[128,  32,   8,    2, 1],</span>
<span class="sd">                        length_keys=[0]),</span>
<span class="sd">    data.AddLossWeights()</span>
<span class="sd">  )</span>

<span class="sd">Each of these combinators creates a python generator of tuples of data examples.</span>
<span class="sd">For example::</span>

<span class="sd">  data.TFDS(&#39;imdb_reviews&#39;, keys=(&#39;text&#39;, &#39;label&#39;), train=True),</span>

<span class="sd">creates a generator of examples from the TFDS imdb_reviews dataset, see here:</span>
<span class="sd">https://www.tensorflow.org/datasets/catalog/imdb_reviews</span>

<span class="sd">As you can see on the website above, this dataset has &#39;text&#39; and &#39;label&#39; fields</span>
<span class="sd">and we create tuples containing the text and the label from the training split</span>
<span class="sd">by specifying keys=(&#39;text&#39;, &#39;label&#39;), train=True.</span>

<span class="sd">The other combinators, like Tokenize and Shuffle, take a generator and output</span>
<span class="sd">another generator, in this way converting tuples into other tuples or mixing</span>
<span class="sd">the training stream. For example, Tokenize(..., keys=[0]) will tokenize the</span>
<span class="sd">first element of the tuple - and in this way convert it from text to a tensor of</span>
<span class="sd">integers. Shuffle will not change the examples, but will randomize their order.</span>

<span class="sd">Note that all elements in the data pipeline are just functions on generators,</span>
<span class="sd">so you can use python&#39;s `map` and `filter` and other native functions too.</span>
<span class="sd">For example, you can create an input pipeline for a language model reading</span>
<span class="sd">lines from `my_file.txt` as follows::</span>

<span class="sd">  inputs = data.Serial(</span>
<span class="sd">    lambda _: open(&#39;my_file.txt&#39;),</span>
<span class="sd">    lambda g: map(lambda line: line.strip(), g),</span>
<span class="sd">    data.Tokenize(vocab_file=&#39;en_8k.subword&#39;),</span>
<span class="sd">    lambda g: filter(lambda x: x.shape[0] &lt; 513, g),  # At most 512 tokens.</span>
<span class="sd">    data.Shuffle(),</span>
<span class="sd">    lambda g: map(lambda x: (x, x)),  # Language models have inputs = targets.</span>
<span class="sd">    data.BucketByLength(boundaries=[  32, 64, 128, 256, 512],</span>
<span class="sd">                        batch_sizes=[ 32, 16,  8,    4,   2, 1]),</span>
<span class="sd">    data.AddLossWeights(id_to_mask=0)</span>
<span class="sd">  )</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">zlib</span>

<span class="kn">from</span> <span class="nn">absl</span> <span class="kn">import</span> <span class="n">logging</span>
<span class="kn">import</span> <span class="nn">gin</span>
<span class="kn">import</span> <span class="nn">jax</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>

<span class="kn">from</span> <span class="nn">trax</span> <span class="kn">import</span> <span class="n">fastmath</span>
<span class="kn">from</span> <span class="nn">trax</span> <span class="kn">import</span> <span class="n">shapes</span>
<span class="kn">from</span> <span class="nn">trax.data</span> <span class="kn">import</span> <span class="n">debug_data_pipeline</span>
<span class="kn">from</span> <span class="nn">trax.fastmath</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">jnp</span>


<div class="viewcode-block" id="Serial"><a class="viewcode-back" href="../../../trax/data/serial.html#trax.data.Serial">[docs]</a><span class="k">def</span> <span class="nf">Serial</span><span class="p">(</span><span class="o">*</span><span class="n">fns</span><span class="p">):</span>  <span class="c1"># pylint: disable=invalid-name</span>
  <span class="sd">&quot;&quot;&quot;Combines generator functions into one that runs them serially.&quot;&quot;&quot;</span>
  <span class="k">def</span> <span class="nf">composed_fns</span><span class="p">(</span><span class="n">generator</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fastmath</span><span class="o">.</span><span class="n">tree_flatten</span><span class="p">(</span><span class="n">fns</span><span class="p">):</span>
      <span class="n">generator</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">generator</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">generator</span>
  <span class="k">return</span> <span class="n">composed_fns</span></div>


<span class="k">def</span> <span class="nf">Parallel</span><span class="p">(</span><span class="n">fns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">counters</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pylint: disable=invalid-name</span>
  <span class="sd">&quot;&quot;&quot;Combines generator functions into one that runs them in parallel.</span>

<span class="sd">  Args:</span>
<span class="sd">    fns: a sequence of datasets which are combined in parallel.</span>
<span class="sd">    counters: a sequence of ints with same length as fns, please see comments on</span>
<span class="sd">      its use below.</span>
<span class="sd">  Returns:</span>
<span class="sd">    parallel_generator: the generator yields samples according to given;</span>
<span class="sd">    if counters are not given then samples are genereted uniformly.</span>

<span class="sd">  Example 1:</span>

<span class="sd">    gen = data.Parallel([dataset1, dataset2, dataset3], counters=(2, 1, 3))</span>

<span class="sd">  defines a generator that yields 33% examples from dataset1, 16% examples from</span>
<span class="sd">  dataset2 and 50% examples from dataset3.</span>

<span class="sd">  Example 2:</span>

<span class="sd">    gen = data.Parallel([dataset1, dataset2, dataset3], counters=(20, 50, 30))</span>

<span class="sd">  defines a generator that yields 20% examples from dataset1, 50% examples from</span>
<span class="sd">  dataset2 and 30% examples from dataset3.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">if</span> <span class="n">counters</span><span class="p">:</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">counters</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">fns</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">counters</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">fns</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">parallel_generator</span><span class="p">(</span><span class="n">gen</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># current_counters are increased step by step; they are reset to 0s when</span>
    <span class="c1"># current_counters[idx] == counters[idx] for all idx. See</span>
    <span class="c1"># test_parallel_with_weights_three_datasets for an example of how</span>
    <span class="c1"># current_counters are changed during computation.</span>

    <span class="n">generators</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fns</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">gen</span><span class="p">:</span>
        <span class="n">generators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">gen</span><span class="p">))</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="c1"># This handles the case when the function f cannot be</span>
        <span class="c1"># called on None.</span>
        <span class="n">generators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">())</span>

    <span class="n">current_counters</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">generators</span><span class="p">)</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">generator</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">generators</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">current_counters</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">counters</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span>
          <span class="n">current_counters</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
          <span class="c1"># instead of checking current_counters[idx] == counters[idx] for</span>
          <span class="c1"># all idx, we check the equivalent condition:</span>
          <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">current_counters</span><span class="p">)</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">(</span><span class="n">counters</span><span class="p">):</span>
            <span class="n">current_counters</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">generators</span><span class="p">)</span>
          <span class="k">yield</span> <span class="nb">next</span><span class="p">(</span><span class="n">generator</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">parallel_generator</span>


<span class="k">def</span> <span class="nf">Log</span><span class="p">(</span><span class="n">n_steps_per_example</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">only_shapes</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>  <span class="c1"># pylint: disable=invalid-name</span>
  <span class="sd">&quot;&quot;&quot;Creates a logging component of the input pipeline.&quot;&quot;&quot;</span>
  <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="n">stream</span><span class="p">):</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">example</span> <span class="ow">in</span> <span class="n">stream</span><span class="p">:</span>
      <span class="n">item_to_log</span> <span class="o">=</span> <span class="n">example</span>
      <span class="k">if</span> <span class="n">only_shapes</span><span class="p">:</span>
        <span class="n">item_to_log</span> <span class="o">=</span> <span class="n">fastmath</span><span class="o">.</span><span class="n">nested_map</span><span class="p">(</span><span class="n">shapes</span><span class="o">.</span><span class="n">signature</span><span class="p">,</span> <span class="n">example</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">counter</span> <span class="o">%</span> <span class="n">n_steps_per_example</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">item_to_log</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">item_to_log</span><span class="p">)</span>
      <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">yield</span> <span class="n">example</span>
  <span class="k">return</span> <span class="n">log</span>


<span class="k">def</span> <span class="nf">shuffle</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">queue_size</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Shuffles a sample stream using a random-out next-in queue of given size.</span>

<span class="sd">  Args:</span>
<span class="sd">    samples: Stream of samples for eventual use as training data or eval data.</span>
<span class="sd">    queue_size: Minimum number of samples within which the streamed shuffling</span>
<span class="sd">        takes place.</span>

<span class="sd">  Yields:</span>
<span class="sd">    Shuffled stream of samples, ready for further processing, e.g., grouping</span>
<span class="sd">    into batches.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">queue_size</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Arg queue_size (</span><span class="si">{</span><span class="n">queue_size</span><span class="si">}</span><span class="s1">) is less than 1.&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">queue_size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Queue size of 1 results in no shuffling.&#39;</span><span class="p">)</span>
  <span class="n">queue</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="c1"># Prep: fill the queue.</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">queue_size</span><span class="p">):</span>
      <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">samples</span><span class="p">))</span>

    <span class="c1"># Core streaming shuffle: yield sample from random location in queue, then</span>
    <span class="c1"># fill that location with new sample from input stream.</span>
    <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">samples</span><span class="p">:</span>
      <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">queue_size</span><span class="p">)</span>
      <span class="k">yield</span> <span class="n">queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
      <span class="n">queue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample</span>
  <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
    <span class="c1"># Only get here if the initial queue fill fails.</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
        <span class="s1">&#39;Not enough samples (</span><span class="si">%d</span><span class="s1">) to fill initial queue (size </span><span class="si">%d</span><span class="s1">).&#39;</span><span class="p">,</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">),</span> <span class="n">queue_size</span><span class="p">)</span>

  <span class="c1"># No new samples coming in; shuffle and drain the queue.</span>
  <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">:</span>
    <span class="k">yield</span> <span class="n">sample</span>


<span class="k">def</span> <span class="nf">Shuffle</span><span class="p">(</span><span class="n">queue_size</span><span class="o">=</span><span class="mi">1024</span><span class="p">):</span>  <span class="c1"># pylint: disable=invalid-name</span>
  <span class="sd">&quot;&quot;&quot;Returns a shuffle function with the given queue size.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">:</span> <span class="n">shuffle</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">queue_size</span><span class="p">)</span>


<span class="n">data_counters</span> <span class="o">=</span> <span class="p">{}</span>


<span class="k">def</span> <span class="nf">save_data_counters</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">host_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Checkpoint data counters.&quot;&quot;&quot;</span>
  <span class="k">global</span> <span class="n">data_counters</span>
  <span class="n">host_id</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">host_id</span><span class="p">()</span> <span class="k">if</span> <span class="n">host_id</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">host_id</span>
  <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s1">&#39;data_counters</span><span class="si">%d</span><span class="s1">.pkl&#39;</span> <span class="o">%</span> <span class="n">host_id</span><span class="p">)</span>
  <span class="k">with</span> <span class="n">tf</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">gfile</span><span class="o">.</span><span class="n">GFile</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data_counters</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">load_data_counters</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">host_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Checkpoint data counters.&quot;&quot;&quot;</span>
  <span class="k">global</span> <span class="n">data_counters</span>
  <span class="n">host_id</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">host_id</span><span class="p">()</span> <span class="k">if</span> <span class="n">host_id</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">host_id</span>
  <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s1">&#39;data_counters</span><span class="si">%d</span><span class="s1">.pkl&#39;</span> <span class="o">%</span> <span class="n">host_id</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">tf</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">gfile</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Did not load data counters as </span><span class="si">%s</span><span class="s1"> does not exist.&#39;</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
    <span class="k">return</span>
  <span class="k">with</span> <span class="n">tf</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">gfile</span><span class="o">.</span><span class="n">GFile</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
  <span class="n">data_counters</span> <span class="o">=</span> <span class="n">obj</span>


<span class="k">def</span> <span class="nf">count_and_skip</span><span class="p">(</span><span class="n">generator</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Count the number of items in the generator, skip already counted ones.</span>

<span class="sd">  This function counts the number of processed examples and puts it into</span>
<span class="sd">  the global variable `counters`. This variable can be saved and restored,</span>
<span class="sd">  and if restored, this function will skip examples until the restored counter</span>
<span class="sd">  is reached. When the data generator is deterministic, this allows to restore</span>
<span class="sd">  the data reading process from a checkpoint.</span>

<span class="sd">  Args:</span>
<span class="sd">    generator: generator for examples in the dataset.</span>
<span class="sd">    name: string, a unique id that we use to count the examples</span>

<span class="sd">  Yields:</span>
<span class="sd">    The examples from generator but first skip the number specified in the</span>
<span class="sd">    global variable counters[name] and next increment this variable every</span>
<span class="sd">    time a new example appears.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">global</span> <span class="n">data_counters</span>
  <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data_counters</span><span class="p">:</span>
    <span class="n">data_counters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">local_counter</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="n">example</span> <span class="ow">in</span> <span class="n">generator</span><span class="p">:</span>
    <span class="n">local_counter</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">local_counter</span> <span class="o">&gt;</span> <span class="n">data_counters</span><span class="p">[</span><span class="n">name</span><span class="p">]:</span>
      <span class="n">data_counters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">yield</span> <span class="n">example</span>


<span class="k">def</span> <span class="nf">CountAndSkip</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>  <span class="c1"># pylint: disable=invalid-name</span>
  <span class="sd">&quot;&quot;&quot;Returns a function that counts and skips examples (see above).&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">:</span> <span class="n">count_and_skip</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">UniformlySeek</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">host_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_hosts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dataset_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pylint: disable=invalid-name</span>
  <span class="sd">&quot;&quot;&quot;Sets each host at (dataset_size/n_hosts)-th of the dataset.&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">dataset_size</span><span class="p">:</span>
    <span class="n">dataset_size</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">18</span>  <span class="c1"># 512 * 512</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
        <span class="s1">&#39;No dataset size given to Uniformly seek, assuming: </span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">dataset_size</span><span class="p">)</span>
  <span class="k">assert</span> <span class="n">name</span>
  <span class="n">host_id</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">host_id</span><span class="p">()</span> <span class="k">if</span> <span class="n">host_id</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">host_id</span>
  <span class="n">n_hosts</span> <span class="o">=</span> <span class="n">n_hosts</span> <span class="ow">or</span> <span class="n">jax</span><span class="o">.</span><span class="n">host_count</span><span class="p">()</span>
  <span class="n">each_host</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dataset_size</span> <span class="o">/</span> <span class="n">n_hosts</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">_f</span><span class="p">(</span><span class="n">generator</span><span class="p">):</span>
    <span class="c1"># Each host seeks to the appropriate point in the dataset.</span>
    <span class="n">num_to_seek</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">host_id</span> <span class="o">*</span> <span class="n">each_host</span><span class="p">)</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Dataset[</span><span class="si">%s</span><span class="s1">] host_id[</span><span class="si">%d</span><span class="s1">] is seeking to position[</span><span class="si">%d</span><span class="s1">]&#39;</span><span class="p">,</span>
                 <span class="n">name</span><span class="p">,</span> <span class="n">host_id</span><span class="p">,</span> <span class="n">num_to_seek</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_to_seek</span><span class="p">):</span>
      <span class="nb">next</span><span class="p">(</span><span class="n">generator</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Dataset[</span><span class="si">%s</span><span class="s1">] host_id[</span><span class="si">%d</span><span class="s1">] reached position[</span><span class="si">%d</span><span class="s1">]. &#39;</span>
                 <span class="s1">&#39;Time taken [</span><span class="si">%s</span><span class="s1">] seconds&#39;</span><span class="p">,</span>
                 <span class="n">name</span><span class="p">,</span> <span class="n">host_id</span><span class="p">,</span> <span class="n">num_to_seek</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">example</span> <span class="ow">in</span> <span class="n">generator</span><span class="p">:</span>
      <span class="k">yield</span> <span class="n">example</span>
  <span class="k">return</span> <span class="n">_f</span>


<span class="k">def</span> <span class="nf">batch</span><span class="p">(</span><span class="n">generator</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Batch and pad generator as in tf.data.Dataset.padded_batch.&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">batch_size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Batch size must be positive, but is </span><span class="si">{</span><span class="n">batch_size</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
  <span class="n">buf</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="n">example</span> <span class="ow">in</span> <span class="n">generator</span><span class="p">:</span>
    <span class="n">buf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>  <span class="c1"># Examples are tuples of tensors.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">==</span> <span class="n">batch_size</span><span class="p">:</span>
      <span class="c1"># buf is a list of tuples, e.g., [(in1, tgt1), (in2, tgt2), (in3, tgt3)]</span>
      <span class="c1"># batch is a tuple of arrays: ([in1, in2, in3], [tgt1, tgt2, tgt3])</span>
      <span class="k">try</span><span class="p">:</span>
        <span class="n">batched_example</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">buf</span><span class="p">))</span>
      <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">buf</span><span class="p">)):</span>
          <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;batch[</span><span class="si">%d</span><span class="s1">] input shape: </span><span class="si">%r</span><span class="s1"> output shape: </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span>
                        <span class="n">i</span><span class="p">,</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;buf: </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">e</span>
      <span class="c1"># Note that it&#39;s the same shape as each example with added batch dim.</span>
      <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">if</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Batch[</span><span class="si">%d</span><span class="s1">] = </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">batched_example</span><span class="p">)</span>
        <span class="n">batched_inputs</span> <span class="o">=</span> <span class="n">batched_example</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">batched_inputs</span><span class="p">):</span>
          <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Input[</span><span class="si">%d</span><span class="s1">][</span><span class="si">%d</span><span class="s1">] = </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">inp</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">batched_inputs</span><span class="p">):</span>
          <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Hash[</span><span class="si">%d</span><span class="s1">][</span><span class="si">%d</span><span class="s1">] = </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">zlib</span><span class="o">.</span><span class="n">adler32</span><span class="p">(</span><span class="nb">bytes</span><span class="p">(</span><span class="n">inp</span><span class="p">)))</span>
      <span class="k">yield</span> <span class="n">batched_example</span>
      <span class="n">buf</span> <span class="o">=</span> <span class="p">[]</span>


<span class="k">def</span> <span class="nf">Batch</span><span class="p">(</span><span class="n">batch_size</span><span class="p">):</span>  <span class="c1"># pylint: disable=invalid-name</span>
  <span class="sd">&quot;&quot;&quot;Returns a batching function with given batch size.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">:</span> <span class="n">batch</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">pad_to_max_dims</span><span class="p">(</span><span class="n">tensors</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict_pad_on_len</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Pad a tuple of tensors to a joint dimension and return their batch.</span>

<span class="sd">  For example, a pair of tensors of shape (2, 10) and (3, 9) will be padded</span>
<span class="sd">  to (3, 10) both and the returned tensor will have shape (2, 3, 10).</span>

<span class="sd">  When boundary is specified, we try to pad all unknown dimensions to boundary</span>
<span class="sd">  if possible, which can help reduce the number of different shapes occurring</span>
<span class="sd">  in the tensors and speed up XLA compilation. So, for example, a pair of</span>
<span class="sd">  tensors of shapes (8, 10), (8, 9) with boundary=12 will be padded to (8, 12).</span>

<span class="sd">  One special case occurs when boundary is much higher than the padding length</span>
<span class="sd">  that we&#39;d use without boundary. For example, tensors (2, 10) and (3, 9) with</span>
<span class="sd">  boundary=12 could end up padded to (12, 12), but this is very wasteful in</span>
<span class="sd">  the first dimension. In that case, we will use the closest power-of-2 instead</span>
<span class="sd">  of the boundary, so the we will end up padding to (4, 12) instead of (12, 12).</span>

<span class="sd">  Args:</span>
<span class="sd">    tensors: a tuple or list of tensors to pad</span>
<span class="sd">    boundary: int or None; if given, expand the padded dimensions to this size</span>
<span class="sd">    strict_pad_on_len: bool; if true we pad on the length dimension, dim[0]</span>
<span class="sd">      strictly as a multiple of boundary.</span>

<span class="sd">  Returns:</span>
<span class="sd">    a tensor, the tensors padded together</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># TODO(afrozm): Unify this later.</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">boundary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span>
      <span class="p">(</span><span class="n">strict_pad_on_len</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">boundary</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)))):</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">boundary</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
      <span class="n">boundary</span> <span class="o">=</span> <span class="p">[</span><span class="n">boundary</span><span class="p">]</span> <span class="o">*</span> <span class="n">ndim</span>

    <span class="k">if</span> <span class="n">ndim</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">boundary</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;ndim != len(boundary) - &#39;</span>
                       <span class="sa">f</span><span class="s1">&#39;ndim(</span><span class="si">{</span><span class="n">ndim</span><span class="si">}</span><span class="s1">) vs boundary(</span><span class="si">{</span><span class="n">boundary</span><span class="si">}</span><span class="s1">) &#39;</span>
                       <span class="sa">f</span><span class="s1">&#39;len(boundary) = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">boundary</span><span class="p">)</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>

    <span class="n">max_len_per_dim</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">ndim</span>
    <span class="k">for</span> <span class="n">tensor</span> <span class="ow">in</span> <span class="n">tensors</span><span class="p">:</span>
      <span class="n">max_len_per_dim</span> <span class="o">=</span> <span class="p">[</span>
          <span class="nb">max</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">max_len_per_dim</span><span class="p">)]</span>

    <span class="c1"># Round everything up to a multiple of boundary in the respective dimension.</span>
    <span class="n">len_per_dim</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">max_len_per_dim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">b</span> <span class="k">else</span> <span class="n">b</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">max_len_per_dim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">boundary</span><span class="p">)]</span>

    <span class="n">padded_tensors</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">len_per_dim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">)],</span>
               <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tensors</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">padded_tensors</span><span class="p">)</span>

  <span class="n">max_len_to_pad</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">padding_needed</span> <span class="o">=</span> <span class="kc">False</span>
  <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tensors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
    <span class="n">max_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tensors</span><span class="p">])</span>
    <span class="n">min_len</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tensors</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">max_len</span> <span class="o">==</span> <span class="n">min_len</span> <span class="ow">and</span> <span class="n">max_len</span> <span class="o">==</span> <span class="n">boundary</span><span class="p">:</span>  <span class="c1"># No padding needed.</span>
      <span class="n">max_len_to_pad</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_len</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">boundary</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">max_len_to_pad</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_len</span><span class="p">)</span>
      <span class="n">padding_needed</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">padding_needed</span> <span class="o">=</span> <span class="kc">True</span>
      <span class="n">cur_boundary</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_len</span><span class="p">,</span> <span class="n">boundary</span><span class="p">)</span>
      <span class="k">if</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">max_len</span> <span class="o">&lt;</span> <span class="n">cur_boundary</span><span class="p">:</span>
        <span class="n">cur_boundary</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">max_len</span><span class="p">)))</span>
      <span class="n">max_len_to_pad</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_boundary</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">padding_needed</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">tensors</span><span class="p">)</span>
  <span class="n">padded_tensors</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tensors</span><span class="p">:</span>
    <span class="n">pad_widths</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_len_to_pad</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">)]</span>
    <span class="n">padded_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">pad_widths</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span>
                      <span class="n">constant_values</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
    <span class="n">padded_tensors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">padded_t</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">padded_tensors</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_buckets_for_length</span><span class="p">(</span><span class="n">bucket_length</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">max_eval_length</span><span class="p">,</span> <span class="n">n_devices</span><span class="p">,</span>
                        <span class="n">training</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Creates heuristically a set of bucket boundaries and sizes.</span>

<span class="sd">  The middle boundary is set to `bucket_length` and the corresponding batch</span>
<span class="sd">  size is set to `batch_size`. We also create buckets of 1/2 and 1/4 length</span>
<span class="sd">  with 2x and 4x batch size, and buckets of 2x and 4x and larger length with</span>
<span class="sd">  1/2 and 1/4 batch size respectively, and batch size 1 for the final one.</span>

<span class="sd">  Args:</span>
<span class="sd">    bucket_length: the length of the middle bucket.</span>
<span class="sd">    batch_size: the batch size for the middle bucket.</span>
<span class="sd">    max_eval_length: the longest bucket length if training=False.</span>
<span class="sd">    n_devices: number of devices, batch sizes are divisible by that.</span>
<span class="sd">    training: bool, whether we are training or evaluating.</span>

<span class="sd">  Returns:</span>
<span class="sd">    a pair of lists of integers, (bucket_boundaries, bucket_batch_sizes).</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">bucket_boundaries</span> <span class="o">=</span> <span class="p">[</span><span class="n">bucket_length</span> <span class="o">//</span> <span class="mi">4</span><span class="p">,</span> <span class="n">bucket_length</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span>
                       <span class="n">bucket_length</span><span class="p">,</span> <span class="n">bucket_length</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
                       <span class="n">bucket_length</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">bucket_length</span> <span class="o">*</span> <span class="mi">8</span><span class="p">,</span>
                       <span class="n">bucket_length</span> <span class="o">*</span> <span class="mi">16</span><span class="p">]</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">training</span><span class="p">:</span>
    <span class="n">max_eval_length</span> <span class="o">=</span> <span class="n">max_eval_length</span> <span class="ow">or</span> <span class="n">bucket_length</span> <span class="o">*</span> <span class="mi">32</span>
    <span class="c1"># Set last bucket boundary to be max_eval_length, cut off boundaries</span>
    <span class="c1"># that are larger than this.</span>
    <span class="n">bucket_boundaries</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bucket_boundaries</span> <span class="k">if</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">max_eval_length</span><span class="p">]</span> <span class="o">+</span>
        <span class="p">[</span><span class="n">max_eval_length</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">bucket_boundaries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_eval_length</span><span class="p">)</span>
  <span class="n">bucket_batch_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">batch_size</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">batch_size</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
                        <span class="n">batch_size</span><span class="p">,</span> <span class="n">batch_size</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span>
                        <span class="n">batch_size</span> <span class="o">//</span> <span class="mi">4</span><span class="p">,</span> <span class="n">batch_size</span> <span class="o">//</span> <span class="mi">8</span><span class="p">,</span>
                        <span class="n">batch_size</span> <span class="o">//</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">training</span><span class="p">:</span>
    <span class="c1"># The last bucket batch size is always 1, but the one-but-last is</span>
    <span class="c1"># sized to accommodate the final length = bucket_boundaries[-1], which</span>
    <span class="c1"># we changed for eval above -- so adjusting here too.</span>

    <span class="c1"># Resize if needed, since bucket_batch_sizes may not be the same size</span>
    <span class="c1"># anymore.</span>
    <span class="n">bucket_batch_sizes</span> <span class="o">=</span> <span class="n">bucket_batch_sizes</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">bucket_boundaries</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">bucket_batch_sizes</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">batch_size</span> <span class="o">//</span> <span class="n">max_eval_length</span>
  <span class="c1"># Make batch sizes divisible by n_devices.</span>
  <span class="n">bucket_batch_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">b</span> <span class="o">//</span> <span class="n">n_devices</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_devices</span>
                        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bucket_batch_sizes</span><span class="p">]</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">bucket_boundaries</span><span class="p">,</span> <span class="n">bucket_batch_sizes</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">bucket_by_length</span><span class="p">(</span><span class="n">generator</span><span class="p">,</span> <span class="n">length_fn</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">,</span> <span class="n">batch_sizes</span><span class="p">,</span>
                     <span class="n">strict_pad_on_len</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Bucket by length, like tf.data.experimental.bucket_by_sequence_length.</span>

<span class="sd">  This function draws examples from the provided `generator` and puts an</span>
<span class="sd">  example into a bucket depending on `l = length_fn(example)`. Which bucket</span>
<span class="sd">  is used depends on between which `boundaries` is l. When a bucket reaches</span>
<span class="sd">  its batch size, as specified by `batch_sizes`, generates a batch of</span>
<span class="sd">  padded examples from this bucket.</span>

<span class="sd">  Args:</span>
<span class="sd">    generator: python generator to draw data from.</span>
<span class="sd">    length_fn: a function taking the example and returning the length.</span>
<span class="sd">    boundaries: a list of bucket boundaries.</span>
<span class="sd">    batch_sizes: a list of batch sizes.</span>
<span class="sd">    strict_pad_on_len: bool; if true we pad on the length dimension, dim[0]</span>
<span class="sd">      strictly as a multiple of boundary.</span>

<span class="sd">  Yields:</span>
<span class="sd">    An input batch, which comes from one of the buckets.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">buckets</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">batch_sizes</span><span class="p">))]</span>
  <span class="n">boundaries</span> <span class="o">=</span> <span class="n">boundaries</span> <span class="o">+</span> <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span>  <span class="c1"># Max boundary is unlimited.</span>
  <span class="k">for</span> <span class="n">example</span> <span class="ow">in</span> <span class="n">generator</span><span class="p">:</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">length_fn</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
    <span class="c1"># `bucket_idx` will always be &lt; len(boundaries), since boundaries is right</span>
    <span class="c1"># padded by `math.inf`.</span>
    <span class="n">bucket_idx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">boundaries</span><span class="p">)</span> <span class="k">if</span> <span class="n">length</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">])</span>
    <span class="n">buckets</span><span class="p">[</span><span class="n">bucket_idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">buckets</span><span class="p">[</span><span class="n">bucket_idx</span><span class="p">])</span> <span class="o">==</span> <span class="n">batch_sizes</span><span class="p">[</span><span class="n">bucket_idx</span><span class="p">]:</span>
      <span class="n">batched</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">buckets</span><span class="p">[</span><span class="n">bucket_idx</span><span class="p">])</span>
      <span class="n">boundary</span> <span class="o">=</span> <span class="n">boundaries</span><span class="p">[</span><span class="n">bucket_idx</span><span class="p">]</span>
      <span class="n">boundary</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">boundary</span> <span class="o">==</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span> <span class="k">else</span> <span class="n">boundary</span>
      <span class="n">padded_batch</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
          <span class="n">pad_to_max_dims</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">boundary</span><span class="p">,</span> <span class="n">strict_pad_on_len</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">batched</span><span class="p">)</span>
      <span class="k">yield</span> <span class="n">padded_batch</span>
      <span class="n">buckets</span><span class="p">[</span><span class="n">bucket_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>


<span class="k">def</span> <span class="nf">_length_fn</span><span class="p">(</span><span class="n">example</span><span class="p">,</span> <span class="n">length_axis</span><span class="p">,</span> <span class="n">length_keys</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Length is the maximum of shape on length_axis over length_keys.&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">example</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">([</span><span class="n">example</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">length_axis</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">length_keys</span><span class="p">])</span>
  <span class="k">return</span> <span class="n">example</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">length_axis</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">BucketByLength</span><span class="p">(</span><span class="n">boundaries</span><span class="p">,</span> <span class="n">batch_sizes</span><span class="p">,</span>  <span class="c1"># pylint: disable=invalid-name</span>
                   <span class="n">length_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">length_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">strict_pad_on_len</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Returns a function for bucketing inputs, see `bucket_by_length`.&quot;&quot;&quot;</span>
  <span class="n">length_keys</span> <span class="o">=</span> <span class="n">length_keys</span> <span class="ow">or</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
  <span class="c1"># In all cases so far, we use a length function of the following form.</span>
  <span class="n">length_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_length_fn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">length_axis</span><span class="p">,</span> <span class="n">length_keys</span><span class="p">)</span>
  <span class="k">return</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">:</span> <span class="n">bucket_by_length</span><span class="p">(</span>  <span class="c1"># pylint: disable=g-long-lambda</span>
      <span class="n">g</span><span class="p">,</span> <span class="n">length_fn</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">,</span> <span class="n">batch_sizes</span><span class="p">,</span> <span class="n">strict_pad_on_len</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">FilterByLength</span><span class="p">(</span><span class="n">max_length</span><span class="p">,</span> <span class="n">min_length</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>  <span class="c1"># pylint: disable=invalid-name</span>
                   <span class="n">length_keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">length_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Returns a function that filters out examples by length.</span>

<span class="sd">  Args:</span>
<span class="sd">    max_length: int. If not None, indicates maximum length.</span>
<span class="sd">    min_length: int. If not None, indicates minimum length.</span>
<span class="sd">    length_keys: (list) which example keys to take into account.</span>
<span class="sd">    length_axis: which shape axis to take into account.</span>
<span class="sd">  Returns:</span>
<span class="sd">    a function that filters out examples by length.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">assert</span> <span class="n">max_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">min_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
  <span class="n">length_keys</span> <span class="o">=</span> <span class="n">length_keys</span> <span class="ow">or</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
  <span class="n">length_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_length_fn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">length_axis</span><span class="p">,</span> <span class="n">length_keys</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">filtered</span><span class="p">(</span><span class="n">gen</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">example</span> <span class="ow">in</span> <span class="n">gen</span><span class="p">:</span>
      <span class="n">example_len</span> <span class="o">=</span> <span class="n">length_fn</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>

      <span class="c1"># Checking max length boundary.</span>
      <span class="k">if</span> <span class="n">max_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">example_len</span> <span class="o">&gt;</span> <span class="n">max_length</span><span class="p">:</span>
          <span class="k">continue</span>
      <span class="c1"># Checking min length boundary.</span>
      <span class="k">if</span> <span class="n">min_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">example_len</span> <span class="o">&lt;</span> <span class="n">min_length</span><span class="p">:</span>
          <span class="k">continue</span>
      <span class="c1"># Within bounds.</span>
      <span class="k">yield</span> <span class="n">example</span>
  <span class="k">return</span> <span class="n">filtered</span>


<span class="k">def</span> <span class="nf">FilterEmptyExamples</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>  <span class="c1"># pylint: disable=invalid-name</span>
  <span class="sd">&quot;&quot;&quot;Filters empty examples.</span>

<span class="sd">  Filters any example that has an array of size (0,) (if axes=None).</span>
<span class="sd">  Alternatively, checks only axes provided in `axes&#39; list. Contrary to</span>
<span class="sd">  FilterByLength used with several elements with length_axis, here the example</span>
<span class="sd">  would be filtered if ANY of the dimensions listed in `axes&#39; contains an empty</span>
<span class="sd">  array.</span>

<span class="sd">  Args:</span>
<span class="sd">    axes: list of indices to check, if None, all of them.</span>
<span class="sd">    debug: If true, emits a log everytime we filter out an empty example.</span>

<span class="sd">  Returns:</span>
<span class="sd">    Function filtering empty examples.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">def</span> <span class="nf">_filter_examples</span><span class="p">(</span><span class="n">generator</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">example</span> <span class="ow">in</span> <span class="n">generator</span><span class="p">:</span>
      <span class="n">correct</span> <span class="o">=</span> <span class="kc">True</span>
      <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">unused_tuple_element</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">example</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">example</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,):</span>
            <span class="n">correct</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">break</span>
      <span class="k">if</span> <span class="n">correct</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">example</span>
      <span class="k">elif</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Filtered example: </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">example</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_filter_examples</span>


<span class="k">def</span> <span class="nf">CastTo</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,),</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>  <span class="c1"># pylint: disable=invalid-name</span>
  <span class="sd">&quot;&quot;&quot;Casts the given indices to the given dtype.&quot;&quot;&quot;</span>
  <span class="k">def</span> <span class="nf">_cast_fn</span><span class="p">(</span><span class="n">generator</span><span class="p">):</span>
    <span class="n">debug_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">example</span> <span class="ow">in</span> <span class="n">generator</span><span class="p">:</span>
      <span class="n">debug_count</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">example</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
      <span class="n">example</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
      <span class="n">dtype_mismatch</span> <span class="o">=</span> <span class="kc">False</span>
      <span class="n">original_index_and_dtype</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">example</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
          <span class="k">continue</span>
        <span class="n">original_type</span> <span class="o">=</span> <span class="n">example</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">if</span> <span class="n">original_type</span> <span class="o">!=</span> <span class="n">dtype</span><span class="p">:</span>
          <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">original_type</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">):</span>
            <span class="c1"># Downcasting from np.int64 to np.int32 is OK</span>
            <span class="n">original_index_and_dtype</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">original_type</span><span class="p">))</span>
          <span class="n">example</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">example</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
          <span class="n">dtype_mismatch</span> <span class="o">=</span> <span class="kc">True</span>
      <span class="k">if</span> <span class="n">debug</span> <span class="ow">and</span> <span class="n">dtype_mismatch</span> <span class="ow">and</span> <span class="n">original_index_and_dtype</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;dtype mismatch in example[</span><span class="si">%d</span><span class="s1">] = </span><span class="si">%r</span><span class="s1"> was earlier: </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span>
                     <span class="n">debug_count</span><span class="p">,</span> <span class="n">example</span><span class="p">,</span> <span class="n">original_index_and_dtype</span><span class="p">)</span>
      <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_cast_fn</span>


<span class="k">def</span> <span class="nf">ConcatenateToLMInput</span><span class="p">(</span><span class="n">pad_to_length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pylint: disable=invalid-name</span>
  <span class="sd">&quot;&quot;&quot;Prepares the input needed for training of Language Models.</span>

<span class="sd">  Each example needs to contain two elements (input and target).</span>
<span class="sd">  Input is concatenated to target and, if pad_to_length is given, padded to</span>
<span class="sd">  length provided.</span>
<span class="sd">  The loss_weights indicates only the target, without input nor padding.</span>

<span class="sd">  Args:</span>
<span class="sd">    pad_to_length: int, total length of padding of input and target arrays.</span>
<span class="sd">  Returns:</span>
<span class="sd">    Function to return input for a LM.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="nd">@debug_data_pipeline</span><span class="o">.</span><span class="n">debug_pipeline</span>
  <span class="k">def</span> <span class="nf">_concatenate_to_lm_input</span><span class="p">(</span><span class="n">generator</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">example</span> <span class="ow">in</span> <span class="n">generator</span><span class="p">:</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">example</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">example</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">concatenated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">example</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">example</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">loss_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">example</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                       <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">example</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
        <span class="k">if</span> <span class="n">pad_to_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
          <span class="n">padding_len</span> <span class="o">=</span> <span class="n">pad_to_length</span> <span class="o">-</span> <span class="p">(</span>
              <span class="n">example</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">example</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
          <span class="k">if</span> <span class="n">padding_len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Example lengths &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="n">example</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">example</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">) &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;longer than pad_to_length (</span><span class="si">{</span><span class="n">pad_to_length</span><span class="si">}</span><span class="s1">).&#39;</span><span class="p">)</span>
          <span class="n">loss_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">loss_weights</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">padding_len</span><span class="p">),</span> <span class="s1">&#39;constant&#39;</span><span class="p">)</span>
          <span class="n">concatenated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">concatenated</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">padding_len</span><span class="p">),</span> <span class="s1">&#39;constant&#39;</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">(</span><span class="n">concatenated</span><span class="p">,</span> <span class="n">concatenated</span><span class="p">,</span> <span class="n">loss_weights</span><span class="p">)</span>
      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">example</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">example</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Make x into (x, x)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">(</span><span class="n">example</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">example</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
      <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">example</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="c1"># Make x into (x, x)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">(</span><span class="n">example</span><span class="p">,</span> <span class="n">example</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unknown input to ConcatenateToLMInput: </span><span class="si">{</span><span class="n">example</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
      <span class="k">yield</span> <span class="n">output</span>

  <span class="k">return</span> <span class="n">_concatenate_to_lm_input</span>


<span class="k">def</span> <span class="nf">PadToLength</span><span class="p">(</span>  <span class="c1"># pylint: disable=invalid-name</span>
    <span class="n">len_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">multiple</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Pads the values to lengths given in `len_map&#39;.</span>

<span class="sd">  len_map contains a dictionary of example keys to dimension sizes.</span>

<span class="sd">  Args:</span>
<span class="sd">    len_map: dict of int to int, we pad examples to lengths</span>
<span class="sd">      given by the values of the dict. If multiple is True, the dimensions are</span>
<span class="sd">      padded to multiple of this value.</span>
<span class="sd">    pad_value: dict of int to int. The value gets applied to</span>
<span class="sd">      constant_values on numpy.pad per given dimension.</span>
<span class="sd">    multiple: boolean. If False, pads to the value of len_map. If True, pads to</span>
<span class="sd">      closest multiple of value of len_map.</span>
<span class="sd">  Returns:</span>
<span class="sd">    Function to pad examples to given lengths.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="nd">@debug_data_pipeline</span><span class="o">.</span><span class="n">debug_pipeline</span>
  <span class="k">def</span> <span class="nf">_pad_to_length</span><span class="p">(</span><span class="n">generator</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">example</span> <span class="ow">in</span> <span class="n">generator</span><span class="p">:</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">example</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">example</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">len_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
          <span class="n">array_length</span> <span class="o">=</span> <span class="n">example</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
          <span class="k">if</span> <span class="n">multiple</span><span class="p">:</span>
            <span class="n">padding_len</span> <span class="o">=</span> <span class="n">array_length</span> <span class="o">-</span> <span class="p">((</span><span class="n">array_length</span> <span class="o">//</span> <span class="n">value</span><span class="p">)</span> <span class="o">*</span> <span class="n">value</span><span class="p">)</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="n">padding_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">value</span><span class="o">-</span><span class="n">example</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
          <span class="n">example</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">example</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                                <span class="n">pad_width</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">padding_len</span><span class="p">),</span>
                                <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span>
                                <span class="n">constant_values</span><span class="o">=</span><span class="n">pad_value</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="n">output</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">example</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
          <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;example isn</span><span class="se">\&#39;</span><span class="s1">t nparray, but should be: </span><span class="si">{</span><span class="n">example</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">array_length</span> <span class="o">=</span> <span class="n">example</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">multiple</span><span class="p">:</span>
          <span class="n">padding_len</span> <span class="o">=</span> <span class="n">array_length</span> <span class="o">-</span> <span class="p">((</span><span class="n">array_length</span> <span class="o">//</span> <span class="n">value</span><span class="p">)</span> <span class="o">*</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">padding_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">len_map</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">array_length</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">example</span><span class="p">,</span>
                        <span class="n">pad_width</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">padding_len</span><span class="p">),</span>
                        <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span>
                        <span class="n">constant_values</span><span class="o">=</span><span class="n">pad_value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
      <span class="k">yield</span> <span class="n">output</span>
  <span class="k">if</span> <span class="n">len_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;len_map parameter should be provided.&#39;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_pad_to_length</span>


<span class="k">def</span> <span class="nf">AppendValue</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pylint: disable=invalid-name</span>
  <span class="sd">&quot;&quot;&quot;Appends values provided in &#39;val` to inputs.</span>

<span class="sd">  val are keyed by example keys, its values contain appended tensors.</span>

<span class="sd">  Args:</span>
<span class="sd">    val: dict of int to tensors. Specific keys get the tensors specified in</span>
<span class="sd">      values appended.</span>
<span class="sd">  Returns:</span>
<span class="sd">    Funtion to append tensors to examples.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="nd">@debug_data_pipeline</span><span class="o">.</span><span class="n">debug_pipeline</span>
  <span class="k">def</span> <span class="nf">_append_value</span><span class="p">(</span><span class="n">generator</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">example</span> <span class="ow">in</span> <span class="n">generator</span><span class="p">:</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">example</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">example</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
          <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">val</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">example</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">example</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">value</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">example</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
          <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;example isn</span><span class="se">\&#39;</span><span class="s1">t nparray, but should be: </span><span class="si">{</span><span class="n">example</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">example</span><span class="p">,</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
      <span class="k">yield</span> <span class="n">output</span>

  <span class="k">return</span> <span class="n">_append_value</span>


<span class="k">def</span> <span class="nf">TruncateToLength</span><span class="p">(</span><span class="n">len_map</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pylint: disable=invalid-name</span>
  <span class="sd">&quot;&quot;&quot;Truncates features in an example to lengths given in `len_map`.</span>

<span class="sd">  len_map contains a dictionary of example keys to tuples of dimension sizes.</span>

<span class="sd">  Args:</span>
<span class="sd">    len_map: dict of int to int tuples (shapes), we truncate examples</span>
<span class="sd">      where a feature&#39;s size is beyond the max. Ex: {0: (1, 512), 1: 64}</span>
<span class="sd">      will truncate examples to be within those bounds.</span>
<span class="sd">  Returns:</span>
<span class="sd">    Function to truncate length of examples.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="nd">@debug_data_pipeline</span><span class="o">.</span><span class="n">debug_pipeline</span>
  <span class="k">def</span> <span class="nf">_truncate_to_length</span><span class="p">(</span><span class="n">generator</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">example</span> <span class="ow">in</span> <span class="n">generator</span><span class="p">:</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">example</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">example</span> <span class="o">=</span> <span class="p">(</span><span class="n">example</span><span class="p">,)</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">example</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">example</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">len_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
          <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">max_len</span> <span class="ow">in</span> <span class="n">len_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">example_len</span> <span class="o">=</span> <span class="n">example</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="n">example_len</span> <span class="o">&gt;</span> <span class="n">max_len</span><span class="p">:</span>
              <span class="n">example</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">example</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">max_len</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unknown example type: </span><span class="si">{</span><span class="n">example</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
      <span class="k">yield</span> <span class="n">output</span>

  <span class="k">return</span> <span class="n">_truncate_to_length</span>


<span class="nd">@debug_data_pipeline</span><span class="o">.</span><span class="n">debug_pipeline</span>
<span class="k">def</span> <span class="nf">add_loss_weights</span><span class="p">(</span><span class="n">generator</span><span class="p">,</span> <span class="n">id_to_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Add weights to inputs without weights and masks by id if requested.</span>

<span class="sd">  The generator stream is augmented in the following way:</span>

<span class="sd">  - If the stream consists of pairs `(inputs, targets)`, a loss mask is added</span>
<span class="sd">    that is creates as a tensor of ones of the same shape as targets.</span>
<span class="sd">  - If `id_to_mask` is not `None`, and the stream (after the previous point)</span>
<span class="sd">    has triples `(inputs, targets, weights)`, the weights are multiplied by a</span>
<span class="sd">    0/1 mask that is 0 iff targets is equal to `id_to_mask` (1 otherwise).</span>

<span class="sd">  Args:</span>
<span class="sd">    generator: Stream of tuples.</span>
<span class="sd">    id_to_mask: If not None, int-valued id that represents padding, as opposed</span>
<span class="sd">        to true target IDs.</span>

<span class="sd">  Yields:</span>
<span class="sd">    Examples from the augmented stream.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">for</span> <span class="n">example</span> <span class="ow">in</span> <span class="n">generator</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">example</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">example</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
      <span class="k">assert</span> <span class="n">id_to_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;Cannot automatically mask this stream.&#39;</span>
      <span class="k">yield</span> <span class="n">example</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">example</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">example</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">example</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
      <span class="n">mask</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">example</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">id_to_mask</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
      <span class="n">weights</span> <span class="o">*=</span> <span class="n">mask</span>
      <span class="n">output</span> <span class="o">=</span> <span class="p">(</span><span class="n">example</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">example</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">weights</span><span class="p">)</span>
      <span class="k">yield</span> <span class="n">output</span>


<span class="k">def</span> <span class="nf">AddLossWeights</span><span class="p">(</span><span class="n">id_to_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># pylint: disable=invalid-name</span>
  <span class="sd">&quot;&quot;&quot;Returns a function to add loss weights; see `add_loss_weights`.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">:</span> <span class="n">add_loss_weights</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">id_to_mask</span><span class="o">=</span><span class="n">id_to_mask</span><span class="p">)</span>


<span class="c1"># Inputs class used for setting up Trainer.</span>
<span class="c1"># Note: as we move from Trainer to Loop this class may become obsolete.</span>


<span class="k">class</span> <span class="nc">Inputs</span><span class="p">:</span>
  <span class="sd">&quot;&quot;&quot;Inputs bundle.</span>

<span class="sd">  Inputs bundle holds input streams and shapes for a training run.</span>
<span class="sd">  It contains stream-creating functions that return python generators</span>
<span class="sd">  of (input_batch, target_batch) tuples.</span>

<span class="sd">  * train_stream: training data that will be used for training</span>
<span class="sd">      may include all the augmentation or selection the training wants</span>
<span class="sd">      the shape of examples is [batch_fn.batch_size, ...]</span>
<span class="sd">  * train_eval_stream: training data used for evaluation</span>
<span class="sd">      examples from training data but usually without augmentation</span>
<span class="sd">      the shape of examples is [batch_fn.eval_batch_size, ...]</span>
<span class="sd">  * eval_stream: evaluation data stream</span>
<span class="sd">      examples from evaluation data, usually without augmentation</span>
<span class="sd">      the shape of examples is [batch_fn.eval_batch_size, ...]</span>
<span class="sd">  * input_shape: the shape of inputs</span>
<span class="sd">      the [...] above, without batch size</span>
<span class="sd">  * input_dtype: the data type of inputs</span>
<span class="sd">  * target_shape: the shape of targets</span>
<span class="sd">      the [...] above, without batch size</span>
<span class="sd">  * target_dtype: the data type of targets</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_stream</span><span class="p">,</span> <span class="n">eval_stream</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">train_eval_stream</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Initialize a new set of inputs.</span>

<span class="sd">    Args:</span>
<span class="sd">      train_stream: a function taking n_devices (an int) and returning</span>
<span class="sd">        a python generator of training batches.</span>
<span class="sd">      eval_stream: a function taking n_devices (an int) and returning</span>
<span class="sd">        a python generator of validation batches;</span>
<span class="sd">        if None, then the training generator will be used for evaluation.</span>
<span class="sd">      train_eval_stream: a function taking n_devices (an int) and returning</span>
<span class="sd">        a python generator of batches from</span>
<span class="sd">        the training set used for evaluation (if None, use train_stream).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">train_stream</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Trax Inputs should be initialized with a function. &#39;</span>
                       <span class="s1">&#39;Did you forget the n_devices argument? If your inputs &#39;</span>
                       <span class="s1">&#39;do not use it, try lambda _: [your-inputs].&#39;</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_train_stream</span> <span class="o">=</span> <span class="n">train_stream</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_eval_stream</span> <span class="o">=</span> <span class="n">eval_stream</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_train_stream</span>

    <span class="c1"># TODO(lukaszkaiser): should we get rid of this one day?</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_train_eval_stream</span> <span class="o">=</span> <span class="n">train_eval_stream</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_train_stream</span>

    <span class="c1"># Peek into the train stream to get an example shape.</span>
    <span class="n">example_train_batch</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">train_stream</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_input_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">example_train_batch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_input_dtype</span> <span class="o">=</span> <span class="n">example_train_batch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_target_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">example_train_batch</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_target_dtype</span> <span class="o">=</span> <span class="n">example_train_batch</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_example_shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">example_train_batch</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_example_dtype</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">example_train_batch</span><span class="p">]</span>

  <span class="k">def</span> <span class="nf">train_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_devices</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_train_stream</span><span class="p">(</span><span class="n">n_devices</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">eval_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_devices</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_stream</span><span class="p">(</span><span class="n">n_devices</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">train_eval_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_devices</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_train_stream</span><span class="p">(</span><span class="n">n_devices</span><span class="p">)</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">input_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Example input shape, without batch dimension.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_shape</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">target_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Example target shape, without batch dimension.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_shape</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">input_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Dtype of the input.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_dtype</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">target_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Dtype of the target.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_dtype</span>

  <span class="nd">@property</span>
  <span class="k">def</span> <span class="nf">example_shape_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Shape and Dtype of an example batch.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_example_shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_example_dtype</span>


<span class="c1"># Batching and Inputs creation helpers.</span>


<span class="nd">@gin</span><span class="o">.</span><span class="n">configurable</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">make_inputs</span><span class="p">(</span><span class="n">train_stream</span><span class="o">=</span><span class="n">gin</span><span class="o">.</span><span class="n">REQUIRED</span><span class="p">,</span> <span class="n">eval_stream</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Create Inputs from two streams; mostly for use in gin configs.&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">train_stream</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
    <span class="n">train_stream</span> <span class="o">=</span> <span class="n">Serial</span><span class="p">(</span><span class="n">train_stream</span><span class="p">)()</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eval_stream</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
    <span class="n">eval_stream</span> <span class="o">=</span> <span class="n">Serial</span><span class="p">(</span><span class="n">eval_stream</span><span class="p">)()</span>
  <span class="n">eval_stream_fn</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">eval_stream</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="n">eval_stream</span>
  <span class="k">return</span> <span class="n">Inputs</span><span class="p">(</span><span class="n">train_stream</span><span class="o">=</span><span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="n">train_stream</span><span class="p">,</span>
                <span class="n">eval_stream</span><span class="o">=</span><span class="n">eval_stream_fn</span><span class="p">)</span>


<span class="nd">@gin</span><span class="o">.</span><span class="n">configurable</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">make_additional_stream</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="n">gin</span><span class="o">.</span><span class="n">REQUIRED</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Create a stream mostly for use in gin configs for additional tasks.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">Serial</span><span class="p">(</span><span class="n">stream</span><span class="p">)()</span>


<span class="nd">@gin</span><span class="o">.</span><span class="n">configurable</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">make_parallel_stream</span><span class="p">(</span><span class="n">streams</span><span class="o">=</span><span class="n">gin</span><span class="o">.</span><span class="n">REQUIRED</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Create a parallel stream for use in gin configs for additional tasks.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">streams</span><span class="p">)()</span>


<span class="nd">@gin</span><span class="o">.</span><span class="n">configurable</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">batcher</span><span class="p">(</span><span class="n">data_streams</span><span class="o">=</span><span class="n">gin</span><span class="o">.</span><span class="n">REQUIRED</span><span class="p">,</span> <span class="n">variable_shapes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">batch_size_per_device</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eval_batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span>
            <span class="n">bucket_length</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">buckets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">buckets_include_inputs_in_length</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">batch_shuffle_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_eval_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="c1"># TODO(afrozm): Unify padding logic.</span>
            <span class="n">id_to_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict_pad_on_len</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Batcher: create trax Inputs from single-example data-streams.&quot;&quot;&quot;</span>
  <span class="c1"># TODO(lukaszkaiser, jonni): revisit arguments, their semantics and naming.</span>
  <span class="c1"># For now leaving the arguments as in batch_fn to reduce gin config changes.</span>
  <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">data_streams</span><span class="p">):</span>  <span class="c1"># If we pass a function, e.g., through gin, call.</span>
    <span class="n">train_stream</span><span class="p">,</span> <span class="n">eval_stream</span> <span class="o">=</span> <span class="n">data_streams</span><span class="p">()</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">train_stream</span><span class="p">,</span> <span class="n">eval_stream</span> <span class="o">=</span> <span class="n">data_streams</span>
  <span class="c1"># pylint: disable=g-long-lambda</span>
  <span class="n">batch_train_stream</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n_devices</span><span class="p">:</span> <span class="n">batch_fn</span><span class="p">(</span>
      <span class="n">train_stream</span><span class="p">(),</span> <span class="kc">True</span><span class="p">,</span> <span class="n">n_devices</span><span class="p">,</span> <span class="n">variable_shapes</span><span class="p">,</span>
      <span class="n">batch_size_per_device</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">eval_batch_size</span><span class="p">,</span>
      <span class="n">bucket_length</span><span class="p">,</span> <span class="n">buckets</span><span class="p">,</span> <span class="n">buckets_include_inputs_in_length</span><span class="p">,</span>
      <span class="n">batch_shuffle_size</span><span class="p">,</span> <span class="n">max_eval_length</span><span class="p">,</span> <span class="n">id_to_mask</span><span class="p">,</span> <span class="n">strict_pad_on_len</span><span class="p">)</span>
  <span class="n">batch_eval_stream</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n_devices</span><span class="p">:</span> <span class="n">batch_fn</span><span class="p">(</span>
      <span class="n">eval_stream</span><span class="p">(),</span> <span class="kc">False</span><span class="p">,</span> <span class="n">n_devices</span><span class="p">,</span> <span class="n">variable_shapes</span><span class="p">,</span>
      <span class="n">batch_size_per_device</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">eval_batch_size</span><span class="p">,</span>
      <span class="n">bucket_length</span><span class="p">,</span> <span class="n">buckets</span><span class="p">,</span> <span class="n">buckets_include_inputs_in_length</span><span class="p">,</span>
      <span class="n">batch_shuffle_size</span><span class="p">,</span> <span class="n">max_eval_length</span><span class="p">,</span> <span class="n">id_to_mask</span><span class="p">,</span> <span class="n">strict_pad_on_len</span><span class="p">)</span>
  <span class="n">batch_train_eval_stream</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n_devices</span><span class="p">:</span> <span class="n">batch_fn</span><span class="p">(</span>
      <span class="n">train_stream</span><span class="p">(),</span> <span class="kc">False</span><span class="p">,</span> <span class="n">n_devices</span><span class="p">,</span> <span class="n">variable_shapes</span><span class="p">,</span>
      <span class="n">batch_size_per_device</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">eval_batch_size</span><span class="p">,</span>
      <span class="n">bucket_length</span><span class="p">,</span> <span class="n">buckets</span><span class="p">,</span> <span class="n">buckets_include_inputs_in_length</span><span class="p">,</span>
      <span class="n">batch_shuffle_size</span><span class="p">,</span> <span class="n">max_eval_length</span><span class="p">,</span> <span class="n">id_to_mask</span><span class="p">,</span> <span class="n">strict_pad_on_len</span><span class="p">)</span>
  <span class="c1"># pylint: enable=g-long-lambda</span>
  <span class="k">return</span> <span class="n">Inputs</span><span class="p">(</span><span class="n">train_stream</span><span class="o">=</span><span class="n">batch_train_stream</span><span class="p">,</span>
                <span class="n">eval_stream</span><span class="o">=</span><span class="n">batch_eval_stream</span><span class="p">,</span>
                <span class="n">train_eval_stream</span><span class="o">=</span><span class="n">batch_train_eval_stream</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">batch_fn</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">training</span><span class="p">,</span> <span class="n">n_devices</span><span class="p">,</span> <span class="n">variable_shapes</span><span class="p">,</span>
             <span class="n">batch_size_per_device</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eval_batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span>
             <span class="n">bucket_length</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">buckets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">buckets_include_inputs_in_length</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">batch_shuffle_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_eval_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">id_to_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict_pad_on_len</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Batching function.&quot;&quot;&quot;</span>
  <span class="c1"># TODO(lukaszkaiser, jonni): revisit arguments, their semantics and naming.</span>
  <span class="c1"># After that, create a proper doc-string; we may also not need to pass both</span>
  <span class="c1"># training and eval arguments here, as batcher calls the function separately</span>
  <span class="c1"># now and it&#39;s not under gin-config any more -- consider reducing args.</span>
  <span class="n">batch_size</span> <span class="o">=</span> <span class="n">batch_size</span> <span class="ow">or</span> <span class="n">batch_size_per_device</span> <span class="o">*</span> <span class="n">n_devices</span>
  <span class="c1"># If bucketing is not specified, check if target shapes are variable.</span>
  <span class="n">cur_batch_size</span> <span class="o">=</span> <span class="n">batch_size</span> <span class="k">if</span> <span class="n">training</span> <span class="k">else</span> <span class="n">eval_batch_size</span>
  <span class="c1"># Make cur_batch_size divisible by n_devices.</span>
  <span class="n">cur_batch_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cur_batch_size</span> <span class="o">//</span> <span class="n">n_devices</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_devices</span>
  <span class="c1"># Create heuristic buckets if none are specified.</span>
  <span class="k">if</span> <span class="n">buckets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Heuristically setting bucketing to </span><span class="si">%s</span><span class="s1"> based on shapes &#39;</span>
                 <span class="s1">&#39;of target tensors.&#39;</span><span class="p">,</span> <span class="n">variable_shapes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">variable_shapes</span><span class="p">:</span>
      <span class="n">buckets</span> <span class="o">=</span> <span class="n">_buckets_for_length</span><span class="p">(</span>
          <span class="n">bucket_length</span><span class="p">,</span> <span class="n">cur_batch_size</span><span class="p">,</span> <span class="n">max_eval_length</span><span class="p">,</span> <span class="n">n_devices</span><span class="p">,</span> <span class="n">training</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">buckets</span><span class="p">:</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Bucketing with buckets </span><span class="si">%s</span><span class="s1">.&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">buckets</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">example_length</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;The length function used by bucket_by_sequence_length to bucket.&quot;&quot;&quot;</span>
      <span class="c1"># The input x is a tuple to go on the stack, typically either</span>
      <span class="c1"># (input, target) or (input, target, mask).</span>
      <span class="n">example_inputs</span><span class="p">,</span> <span class="n">target</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
      <span class="c1"># Length is the shape of axis 0 here (no batch yet).</span>
      <span class="n">other_length</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># We include input length only if asked.</span>
      <span class="k">if</span> <span class="n">buckets_include_inputs_in_length</span><span class="p">:</span>
        <span class="n">other_length</span> <span class="o">=</span> <span class="n">example_inputs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
      <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">other_length</span><span class="p">)</span>
    <span class="n">boundaries</span><span class="p">,</span> <span class="n">batch_sizes</span> <span class="o">=</span> <span class="n">buckets</span>
    <span class="n">dataset</span> <span class="o">=</span> <span class="n">bucket_by_length</span><span class="p">(</span>
        <span class="n">dataset</span><span class="p">,</span> <span class="n">example_length</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">,</span> <span class="n">batch_sizes</span><span class="p">,</span> <span class="n">strict_pad_on_len</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Not Bucketing cur_batch_size </span><span class="si">%d</span><span class="s1">.&#39;</span><span class="p">,</span> <span class="n">cur_batch_size</span><span class="p">)</span>
    <span class="n">dataset</span> <span class="o">=</span> <span class="n">batch</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">cur_batch_size</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">training</span> <span class="ow">and</span> <span class="n">batch_shuffle_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">dataset</span> <span class="o">=</span> <span class="n">shuffle</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">batch_shuffle_size</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">add_loss_weights</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">id_to_mask</span><span class="p">)</span>


<span class="c1"># Example input functions.</span>


<span class="nd">@gin</span><span class="o">.</span><span class="n">configurable</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">random_inputs</span><span class="p">(</span>
    <span class="n">input_shape</span><span class="o">=</span><span class="n">gin</span><span class="o">.</span><span class="n">REQUIRED</span><span class="p">,</span> <span class="n">input_dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">input_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span>
    <span class="n">output_shape</span><span class="o">=</span><span class="n">gin</span><span class="o">.</span><span class="n">REQUIRED</span><span class="p">,</span> <span class="n">output_dtype</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">output_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">)):</span>
  <span class="sd">&quot;&quot;&quot;Make random Inputs for debugging.</span>

<span class="sd">  Args:</span>
<span class="sd">    input_shape: the shape of inputs (including batch dimension).</span>
<span class="sd">    input_dtype: the type of the inputs (int32 by default).</span>
<span class="sd">    input_range: the range of inputs (defaults to (0, 255)).</span>
<span class="sd">    output_shape: the shape of outputs (including batch dimension).</span>
<span class="sd">    output_dtype: the type of the outputs (int32 by default).</span>
<span class="sd">    output_range: the range of outputs (defaults to (0, 9)).</span>

<span class="sd">  Returns:</span>
<span class="sd">    trax.inputs.Inputs</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">def</span> <span class="nf">random_minibatches</span><span class="p">(</span><span class="n">n_devices</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate a stream of random mini-batches.&quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">input_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="n">n_devices</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">input_dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">float16</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">float64</span><span class="p">]:</span>
      <span class="n">rand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">rand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_integers</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
      <span class="n">inp</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="n">input_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">input_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">input_shape</span><span class="p">)</span>
      <span class="n">inp</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">input_dtype</span><span class="p">)</span>
      <span class="n">out</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="n">output_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">output_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">output_shape</span><span class="p">)</span>
      <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">output_dtype</span><span class="p">)</span>
      <span class="k">yield</span> <span class="n">inp</span><span class="p">,</span> <span class="n">out</span>

  <span class="k">return</span> <span class="n">Inputs</span><span class="p">(</span><span class="n">random_minibatches</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_pad_to_multiple_of</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Pads x to multiple of y on the given axis.&quot;&quot;&quot;</span>
  <span class="n">pad_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="o">*</span> <span class="n">y</span>
  <span class="n">pad_widths</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
  <span class="n">pad_widths</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">pad_len</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]))</span>
  <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pad_widths</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span>
                <span class="n">constant_values</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>


<span class="nd">@gin</span><span class="o">.</span><span class="n">configurable</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">sequence_copy_inputs</span><span class="p">(</span>
    <span class="n">vocab_size</span><span class="o">=</span><span class="n">gin</span><span class="o">.</span><span class="n">REQUIRED</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">gin</span><span class="o">.</span><span class="n">REQUIRED</span><span class="p">,</span> <span class="n">train_length</span><span class="o">=</span><span class="n">gin</span><span class="o">.</span><span class="n">REQUIRED</span><span class="p">,</span>
    <span class="n">eval_min_length</span><span class="o">=</span><span class="n">gin</span><span class="o">.</span><span class="n">REQUIRED</span><span class="p">,</span> <span class="n">eval_max_length</span><span class="o">=</span><span class="n">gin</span><span class="o">.</span><span class="n">REQUIRED</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">pad_to_multiple</span><span class="o">=</span><span class="mi">32</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Inputs for the sequence copy problem: 0w0w for w in [1..vocab_size-1]*.</span>

<span class="sd">  Args:</span>
<span class="sd">    vocab_size: how many symbols to use.</span>
<span class="sd">    batch_size: how large are the batches.</span>
<span class="sd">    train_length: maximum length of w for training.</span>
<span class="sd">    eval_min_length: minimum length of w for eval.</span>
<span class="sd">    eval_max_length : maximum length of w for eval.</span>
<span class="sd">    reverse: bool (optional, false by default): reverse the second sequence.</span>
<span class="sd">    pad_to_multiple: int, pad length to be multiple of this number.</span>

<span class="sd">  Returns:</span>
<span class="sd">    trax.inputs.Inputs</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">def</span> <span class="nf">random_minibatches</span><span class="p">(</span><span class="n">length_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate a stream of random mini-batches.&quot;&quot;&quot;</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
      <span class="n">length</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">length_list</span><span class="p">)</span>
      <span class="k">assert</span> <span class="n">length</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
      <span class="n">w_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">length</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
      <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">vocab_size</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                            <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">w_length</span><span class="p">))</span>
      <span class="n">zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">batch_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
      <span class="n">loss_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">w_length</span><span class="o">+</span><span class="mi">2</span><span class="p">)),</span>
                                     <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">w_length</span><span class="p">))],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">zero</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">zero</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">zero</span><span class="p">,</span> <span class="n">w</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">x</span> <span class="o">=</span> <span class="n">_pad_to_multiple_of</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pad_to_multiple</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
      <span class="n">loss_weights</span> <span class="o">=</span> <span class="n">_pad_to_multiple_of</span><span class="p">(</span><span class="n">loss_weights</span><span class="p">,</span> <span class="n">pad_to_multiple</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
      <span class="k">yield</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">loss_weights</span><span class="p">)</span>  <span class="c1"># Here inputs and targets are the same.</span>

  <span class="n">train_lengths</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">train_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
  <span class="n">eval_lengths</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">eval_min_length</span><span class="p">,</span> <span class="n">eval_max_length</span><span class="p">)]</span>
  <span class="k">return</span> <span class="n">Inputs</span><span class="p">(</span>
      <span class="n">train_stream</span><span class="o">=</span><span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="n">random_minibatches</span><span class="p">(</span><span class="n">train_lengths</span><span class="p">),</span>
      <span class="n">eval_stream</span><span class="o">=</span><span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="n">random_minibatches</span><span class="p">(</span><span class="n">eval_lengths</span><span class="p">)</span>
  <span class="p">)</span>


<span class="nd">@gin</span><span class="o">.</span><span class="n">configurable</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">simple_sequence_copy_inputs</span><span class="p">(</span>
    <span class="n">vocab_size</span><span class="o">=</span><span class="n">gin</span><span class="o">.</span><span class="n">REQUIRED</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">gin</span><span class="o">.</span><span class="n">REQUIRED</span><span class="p">,</span> <span class="n">train_length</span><span class="o">=</span><span class="n">gin</span><span class="o">.</span><span class="n">REQUIRED</span><span class="p">,</span>
    <span class="n">eval_min_length</span><span class="o">=</span><span class="n">gin</span><span class="o">.</span><span class="n">REQUIRED</span><span class="p">,</span> <span class="n">eval_max_length</span><span class="o">=</span><span class="n">gin</span><span class="o">.</span><span class="n">REQUIRED</span><span class="p">,</span>
    <span class="n">pad_to_multiple</span><span class="o">=</span><span class="mi">32</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Inputs for the sequence copy problem: w for w in [1..vocab_size-1]*.</span>

<span class="sd">  Args:</span>
<span class="sd">    vocab_size: how many symbols to use.</span>
<span class="sd">    batch_size: how large are the batches.</span>
<span class="sd">    train_length: maximum length of w for training.</span>
<span class="sd">    eval_min_length: minimum length of w for eval.</span>
<span class="sd">    eval_max_length : maximum length of w for eval.</span>
<span class="sd">    pad_to_multiple: int, pad length to be multiple of this number.</span>

<span class="sd">  Returns:</span>
<span class="sd">    trax.inputs.Inputs</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">def</span> <span class="nf">random_minibatches</span><span class="p">(</span><span class="n">length_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate a stream of random mini-batches.&quot;&quot;&quot;</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
      <span class="n">length</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">length_list</span><span class="p">)</span>
      <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">vocab_size</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                            <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">length</span><span class="p">))</span>
      <span class="n">loss_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">length</span><span class="p">))</span>
      <span class="n">x</span> <span class="o">=</span> <span class="n">_pad_to_multiple_of</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pad_to_multiple</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
      <span class="n">loss_weights</span> <span class="o">=</span> <span class="n">_pad_to_multiple_of</span><span class="p">(</span><span class="n">loss_weights</span><span class="p">,</span> <span class="n">pad_to_multiple</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
      <span class="k">yield</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">loss_weights</span><span class="p">)</span>  <span class="c1"># Here inputs and targets are the same.</span>

  <span class="n">train_lengths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">train_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
  <span class="n">eval_lengths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">eval_min_length</span><span class="p">,</span> <span class="n">eval_max_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">Inputs</span><span class="p">(</span>
      <span class="n">train_stream</span><span class="o">=</span><span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="n">random_minibatches</span><span class="p">(</span><span class="n">train_lengths</span><span class="p">),</span>
      <span class="n">eval_stream</span><span class="o">=</span><span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="n">random_minibatches</span><span class="p">(</span><span class="n">eval_lengths</span><span class="p">)</span>
  <span class="p">)</span>


<span class="k">def</span> <span class="nf">lower_endian_to_number</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Helper function: convert a list of digits in the given base to a number.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">d</span> <span class="o">*</span> <span class="p">(</span><span class="n">base</span><span class="o">**</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">l</span><span class="p">)])</span>


<span class="k">def</span> <span class="nf">number_to_lower_endian</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Helper function: convert a number to a list of digits in the given base.&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">base</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">n</span> <span class="o">%</span> <span class="n">base</span><span class="p">]</span> <span class="o">+</span> <span class="n">number_to_lower_endian</span><span class="p">(</span><span class="n">n</span> <span class="o">//</span> <span class="n">base</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">random_number_lower_endian</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Helper function: generate a random number as a lower-endian digits list.&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">length</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Last digit can be 0 only if length is 1.</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">base</span><span class="p">)]</span>
  <span class="n">prefix</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
  <span class="k">return</span> <span class="n">prefix</span> <span class="o">+</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">base</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># Last digit is not 0.</span>


<span class="nd">@gin</span><span class="o">.</span><span class="n">configurable</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">addition_inputs</span><span class="p">(</span>
    <span class="n">vocab_size</span><span class="o">=</span><span class="n">gin</span><span class="o">.</span><span class="n">REQUIRED</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">gin</span><span class="o">.</span><span class="n">REQUIRED</span><span class="p">,</span> <span class="n">train_length</span><span class="o">=</span><span class="n">gin</span><span class="o">.</span><span class="n">REQUIRED</span><span class="p">,</span>
    <span class="n">eval_min_length</span><span class="o">=</span><span class="n">gin</span><span class="o">.</span><span class="n">REQUIRED</span><span class="p">,</span> <span class="n">eval_max_length</span><span class="o">=</span><span class="n">gin</span><span class="o">.</span><span class="n">REQUIRED</span><span class="p">,</span>
    <span class="n">pad_to_multiple</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">encdec</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Inputs for the add problem: &lt;S&gt;x+y&lt;S&gt;(x+y).</span>

<span class="sd">  Args:</span>
<span class="sd">    vocab_size: how many symbols to use.</span>
<span class="sd">    batch_size: how large are the batches.</span>
<span class="sd">    train_length: maximal length of w for training.</span>
<span class="sd">    eval_min_length: minimal length of w for eval.</span>
<span class="sd">    eval_max_length: maximal length of w for eval.</span>
<span class="sd">    pad_to_multiple: int, pad length to be multiple of this number.</span>
<span class="sd">    encdec: bool, if True return encoder-decoder style inputs (default: False)</span>

<span class="sd">  Returns:</span>
<span class="sd">    trax.inputs.Inputs</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">base</span> <span class="o">=</span> <span class="n">vocab_size</span> <span class="o">-</span> <span class="mi">3</span>  <span class="c1"># We use 0 to pad, base+1 as &quot;+&quot; and base+2 as &quot;&lt;S&gt;&quot;.</span>
  <span class="k">def</span> <span class="nf">single_example</span><span class="p">(</span><span class="n">max_length</span><span class="p">,</span> <span class="n">min_length</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate a stream of random mini-batches.&quot;&quot;&quot;</span>
    <span class="n">add_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">l1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">((</span><span class="n">max_length</span> <span class="o">-</span> <span class="n">add_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">add_len</span>
    <span class="n">l2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">max_length</span> <span class="o">-</span> <span class="n">l1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="n">random_number_lower_endian</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
    <span class="n">n2</span> <span class="o">=</span> <span class="n">random_number_lower_endian</span><span class="p">(</span><span class="n">l2</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">lower_endian_to_number</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span> <span class="o">+</span> <span class="n">lower_endian_to_number</span><span class="p">(</span>
        <span class="n">n2</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
    <span class="n">inp</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="p">[</span><span class="n">base</span><span class="p">]</span> <span class="o">+</span> <span class="n">n2</span>
    <span class="n">tgt</span> <span class="o">=</span> <span class="n">number_to_lower_endian</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">encdec</span><span class="p">:</span>
      <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inp</span><span class="p">]</span>
      <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tgt</span><span class="p">]</span>
      <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">tgt</span><span class="p">)</span>
      <span class="n">candidate_example</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights</span><span class="p">))</span>
      <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_length</span> <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">candidate_example</span><span class="p">):</span>
        <span class="c1"># sample too long, try again</span>
        <span class="k">return</span> <span class="n">single_example</span><span class="p">(</span><span class="n">max_length</span><span class="p">,</span> <span class="n">min_length</span><span class="p">)</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">base</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inp</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">base</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tgt</span><span class="p">]</span>
      <span class="n">weights</span> <span class="o">=</span> <span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="p">([</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">tgt</span><span class="p">))</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights</span><span class="p">))</span>

  <span class="k">def</span> <span class="nf">batches</span><span class="p">(</span><span class="n">max_length</span><span class="p">,</span> <span class="n">min_length</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Batches of examples.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">max_length</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">min_length</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Maximum/minimum length must be at least 3.&#39;</span><span class="p">)</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
      <span class="n">ex</span> <span class="o">=</span> <span class="p">[</span><span class="n">single_example</span><span class="p">(</span><span class="n">max_length</span><span class="p">,</span> <span class="n">min_length</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)]</span>
      <span class="n">padded_batch</span> <span class="o">=</span> <span class="p">[</span><span class="n">pad_to_max_dims</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="n">pad_to_multiple</span><span class="p">,</span>
                                      <span class="n">strict_pad_on_len</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">ex</span><span class="p">)]</span>
      <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">padded_batch</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">Inputs</span><span class="p">(</span>
      <span class="n">train_stream</span><span class="o">=</span><span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="n">batches</span><span class="p">(</span><span class="n">train_length</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
      <span class="n">eval_stream</span><span class="o">=</span><span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="n">batches</span><span class="p">(</span><span class="n">eval_max_length</span><span class="p">,</span> <span class="n">eval_min_length</span><span class="p">)</span>
  <span class="p">)</span>


<span class="c1"># This is a straightforward translation of T5&#39;s random_spans_noise_mask.</span>
<span class="k">def</span> <span class="nf">random_spans_noise_mask</span><span class="p">(</span><span class="n">length</span><span class="p">,</span>
                            <span class="n">noise_density</span><span class="o">=</span><span class="mf">0.15</span><span class="p">,</span>
                            <span class="n">mean_noise_span_length</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span>
                            <span class="n">seed1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">seed2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">example</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Computes span corruption masks given input parameters.&quot;&quot;&quot;</span>
  <span class="c1"># Passing this in case if we want to use for debugging/logging</span>
  <span class="k">del</span> <span class="n">example</span>
  <span class="n">orig_length</span> <span class="o">=</span> <span class="n">length</span>
  <span class="c1"># increase length to avoid degeneracy</span>
  <span class="n">length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
  <span class="n">num_noise_tokens</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">length</span> <span class="o">*</span> <span class="n">noise_density</span><span class="p">))</span>
  <span class="c1"># avoid degeneracy by ensuring positive numbers of noise and nonnoise tokens.</span>
  <span class="n">num_noise_tokens</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">num_noise_tokens</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">num_noise_spans</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">num_noise_tokens</span> <span class="o">/</span> <span class="n">mean_noise_span_length</span><span class="p">))</span>
  <span class="c1"># avoid degeneracy by ensuring positive number of noise spans</span>
  <span class="n">num_noise_spans</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">num_noise_spans</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">num_nonnoise_tokens</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="n">num_noise_tokens</span>

  <span class="c1"># Pick the lengths of the noise spans and the non-noise spans</span>
  <span class="k">def</span> <span class="nf">randomly_segment</span><span class="p">(</span><span class="n">num_items</span><span class="p">,</span> <span class="n">num_segments</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_items</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_segments</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="c1"># Set random seed if passed (only in tests for now).</span>
    <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">first_in_segment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">)</span>
    <span class="n">segment_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">first_in_segment</span><span class="p">)</span>

    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">segment_id</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">segment_id</span> <span class="o">-</span> <span class="n">y</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                  <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                  <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">)</span>
    <span class="n">segment_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">segment_id</span><span class="p">),</span> <span class="n">idxs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">segment_lengths</span>

  <span class="n">noise_span_lengths</span> <span class="o">=</span> <span class="n">randomly_segment</span><span class="p">(</span>
      <span class="n">num_noise_tokens</span><span class="p">,</span> <span class="n">num_noise_spans</span><span class="p">,</span> <span class="n">seed1</span><span class="p">)</span>
  <span class="n">nonnoise_span_lengths</span> <span class="o">=</span> <span class="n">randomly_segment</span><span class="p">(</span>
      <span class="n">num_nonnoise_tokens</span><span class="p">,</span> <span class="n">num_noise_spans</span><span class="p">,</span> <span class="n">seed2</span><span class="p">)</span>
  <span class="n">interleaved_span_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
      <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">nonnoise_span_lengths</span><span class="p">,</span> <span class="n">noise_span_lengths</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
      <span class="p">[</span><span class="n">num_noise_spans</span> <span class="o">*</span> <span class="mi">2</span><span class="p">])</span>
  <span class="n">span_starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">interleaved_span_lengths</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="n">span_start_indicator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">length</span><span class="p">)</span>  <span class="c1"># all 0s to begin with</span>
  <span class="n">span_start_indicator</span><span class="p">[</span><span class="n">span_starts</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">span_num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">span_start_indicator</span><span class="p">)</span>
  <span class="n">is_noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">span_num</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">is_noise</span><span class="p">[:</span><span class="n">orig_length</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">generate_sequential_chunks</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Returns a function that generates chunks of atmost max_length length.&quot;&quot;&quot;</span>
  <span class="k">def</span> <span class="nf">_f</span><span class="p">(</span><span class="n">generator</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">example</span> <span class="ow">in</span> <span class="n">generator</span><span class="p">:</span>
      <span class="n">n_tokens</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">n_tokens</span> <span class="o">&lt;=</span> <span class="n">max_length</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">example</span>
      <span class="n">n_segments</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">n_tokens</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">max_length</span><span class="p">)))</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_segments</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">max_length</span> <span class="o">*</span> <span class="n">i</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">max_length</span><span class="p">,</span> <span class="n">n_tokens</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">example</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">_f</span>


<span class="k">def</span> <span class="nf">generate_random_noise_mask</span><span class="p">(</span><span class="n">noise_density</span><span class="o">=</span><span class="mf">0.15</span><span class="p">,</span>
                               <span class="n">mean_noise_span_length</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span>
                               <span class="n">seed1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">seed2</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Returns a function that generates a random noise mask.&quot;&quot;&quot;</span>
  <span class="k">def</span> <span class="nf">_f</span><span class="p">(</span><span class="n">generator</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">example</span> <span class="ow">in</span> <span class="n">generator</span><span class="p">:</span>
      <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
      <span class="n">noise_mask</span> <span class="o">=</span> <span class="n">random_spans_noise_mask</span><span class="p">(</span>
          <span class="n">length</span><span class="p">,</span> <span class="n">noise_density</span><span class="o">=</span><span class="n">noise_density</span><span class="p">,</span>
          <span class="n">mean_noise_span_length</span><span class="o">=</span><span class="n">mean_noise_span_length</span><span class="p">,</span>
          <span class="n">seed1</span><span class="o">=</span><span class="n">seed1</span><span class="p">,</span> <span class="n">seed2</span><span class="o">=</span><span class="n">seed2</span><span class="p">,</span> <span class="n">example</span><span class="o">=</span><span class="n">example</span><span class="p">)</span>
      <span class="k">yield</span> <span class="p">(</span><span class="n">example</span><span class="p">,</span> <span class="n">noise_mask</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_f</span>


<span class="k">def</span> <span class="nf">consume_noise_mask</span><span class="p">(</span><span class="n">vocab_size</span><span class="o">=</span><span class="mi">32100</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Consumes (tokens, noise mask) and returns (inputs, targets).&quot;&quot;&quot;</span>
  <span class="k">def</span> <span class="nf">_noise_span_to_unique_sentinel</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="n">noise_mask</span><span class="p">):</span>
    <span class="n">prev_token_is_noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
        <span class="n">noise_mask</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">first_noise_tokens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">noise_mask</span><span class="p">,</span>
                                        <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">prev_token_is_noise</span><span class="p">))</span>
    <span class="n">subsequent_noise_tokens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">noise_mask</span><span class="p">,</span> <span class="n">prev_token_is_noise</span><span class="p">)</span>
    <span class="n">sentinel</span> <span class="o">=</span> <span class="n">vocab_size</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">first_noise_tokens</span><span class="p">)</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">first_noise_tokens</span><span class="p">,</span> <span class="n">sentinel</span><span class="p">,</span> <span class="n">tokens</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tokens</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">subsequent_noise_tokens</span><span class="p">)]</span>

  <span class="k">def</span> <span class="nf">_f</span><span class="p">(</span><span class="n">generator</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">noise_mask</span> <span class="ow">in</span> <span class="n">generator</span><span class="p">:</span>
      <span class="c1"># Returns inputs and targets.</span>
      <span class="k">yield</span> <span class="p">(</span><span class="n">_noise_span_to_unique_sentinel</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="n">noise_mask</span><span class="p">),</span>
             <span class="n">_noise_span_to_unique_sentinel</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">noise_mask</span><span class="p">)))</span>
  <span class="k">return</span> <span class="n">_f</span>


<span class="k">def</span> <span class="nf">generate_prefix_lm_sequential_chunks</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Returns a function that generates prefix lm chunks of max_length length.&quot;&quot;&quot;</span>
  <span class="k">def</span> <span class="nf">_f</span><span class="p">(</span><span class="n">generator</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">example</span> <span class="ow">in</span> <span class="n">generator</span><span class="p">:</span>
      <span class="n">n_tokens</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
      <span class="c1"># Don&#39;t want extremely short chunks.</span>
      <span class="k">if</span> <span class="n">n_tokens</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">continue</span>
      <span class="c1"># The whole document is less than max_length.</span>
      <span class="k">if</span> <span class="n">n_tokens</span> <span class="o">&lt;=</span> <span class="n">max_length</span><span class="p">:</span>
        <span class="c1"># Generate a shorter input output pair.</span>
        <span class="n">half</span> <span class="o">=</span> <span class="n">n_tokens</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">yield</span> <span class="p">(</span><span class="n">example</span><span class="p">[:</span><span class="n">half</span><span class="p">],</span> <span class="n">example</span><span class="p">[</span><span class="n">half</span><span class="p">:])</span>
      <span class="n">n_segments</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">n_tokens</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">max_length</span><span class="p">)))</span>
      <span class="c1"># Go over all but the last segment and make (overlapping) pairs.</span>
      <span class="c1"># So with | showing chunks, the following doc:</span>
      <span class="c1"># | 1 2 3 | 4 5 6 | 7 8</span>
      <span class="c1"># Makes i/o pairs:</span>
      <span class="c1"># (1 2 3, 4 5 6), (4 5 6, 7 8)</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_segments</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">start1</span> <span class="o">=</span> <span class="n">max_length</span> <span class="o">*</span> <span class="n">i</span>
        <span class="n">start2</span> <span class="o">=</span> <span class="n">start1</span> <span class="o">+</span> <span class="n">max_length</span>
        <span class="n">end2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">start2</span> <span class="o">+</span> <span class="n">max_length</span><span class="p">,</span> <span class="n">n_tokens</span><span class="p">)</span>
        <span class="k">yield</span> <span class="p">(</span><span class="n">example</span><span class="p">[</span><span class="n">start1</span><span class="p">:</span><span class="n">start2</span><span class="p">],</span> <span class="n">example</span><span class="p">[</span><span class="n">start2</span><span class="p">:</span><span class="n">end2</span><span class="p">])</span>
  <span class="k">return</span> <span class="n">_f</span>


<span class="k">def</span> <span class="nf">MixMLMAndPrefixLM</span><span class="p">(</span><span class="n">mlm_rate</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>  <span class="c1"># pylint:disable=invalid-name</span>
                      <span class="n">prefix_lm_rate</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                      <span class="n">noise_density</span><span class="o">=</span><span class="mf">0.15</span><span class="p">,</span>
                      <span class="n">mean_noise_span_length</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span>
                      <span class="n">vocab_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">max_length</span><span class="o">=</span><span class="mi">512</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;Parallel between MLM and PrefixLM outputs.&quot;&quot;&quot;</span>
  <span class="k">assert</span> <span class="n">vocab_size</span>
  <span class="n">mlm</span> <span class="o">=</span> <span class="n">Serial</span><span class="p">(</span>
      <span class="c1"># Generate sequential chunks - take one away from max_length, since 1 will</span>
      <span class="c1"># be appended later.</span>
      <span class="n">generate_sequential_chunks</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="n">max_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
      <span class="c1"># Generate mask and chunk.</span>
      <span class="n">generate_random_noise_mask</span><span class="p">(</span>
          <span class="n">noise_density</span><span class="o">=</span><span class="n">noise_density</span><span class="p">,</span>
          <span class="n">mean_noise_span_length</span><span class="o">=</span><span class="n">mean_noise_span_length</span><span class="p">),</span>
      <span class="c1"># Consume mask and chunk to give (input, targets).</span>
      <span class="n">consume_noise_mask</span><span class="p">(</span><span class="n">vocab_size</span><span class="o">=</span><span class="n">vocab_size</span><span class="p">),</span>
  <span class="p">)</span>
  <span class="k">if</span> <span class="n">mlm_rate</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">prefix_lm_rate</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">mlm</span>
  <span class="n">prefix_lm</span> <span class="o">=</span> <span class="n">generate_prefix_lm_sequential_chunks</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="n">max_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">prefix_lm_rate</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">mlm_rate</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">prefix_lm</span>
  <span class="k">return</span> <span class="n">Parallel</span><span class="p">([</span><span class="n">mlm</span><span class="p">,</span> <span class="n">prefix_lm</span><span class="p">],</span> <span class="n">counters</span><span class="o">=</span><span class="p">(</span><span class="n">mlm_rate</span><span class="p">,</span> <span class="n">prefix_lm_rate</span><span class="p">))</span>
</pre></div>

    </div>
      
  </div>
</div>
  <footer class="footer">
    <div class="container">
      <p class="pull-right">
        <a href="#">Back to top</a>
        
      </p>

      <p xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/"><a property="dct:title" rel="cc:attributionURL" href="https://necromuralist.github.io/Anechoic-Echolalia/">Anechoic Echolalia</a> by <a rel="cc:attributionURL dct:creator" property="cc:attributionName" href="https://github.com/necromuralist">The Cloistered Monkey</a> is licensed under <a href="http://creativecommons.org/licenses/by/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">CC BY 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"></a>
          Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.5.1.<br/>

      </p>
    </div>
  </footer>
  

  </body>
</html>